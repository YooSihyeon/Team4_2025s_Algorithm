# Team4_2025s_Algorithm 
알고리즘 중간고사 Team4
---

## 👥팀원

- 김수빈 (경영AI / 22200105)  
- 양찬 (ACE,DS / 22000415)  
- 유시현 (ICT&DS / 22000457)  
- 김찬우 (생명AI / 21900197)

---

## 🗂️ 브런치 및 파일 구조


| 브랜치 이름     | 설명                            | 포함 파일 예시                                  |
|----------------|----------------------------------|-------------------------------------------------|
| `main`         | 최종 문제 풀이 및 주요 파일 저장                     | `.gitignore`, `README.md`, `problem1.ipynb` 등        |
| `dev` | 전체적인 개발 관련 파일 저장          |  |
| `feature/problem1` | 문제 1번 관련 소스코드들 저장    | `Bubble_Sort.py`, `Insertion Sort.py` 등     |
| `feature/problem2` | 문제 2번 관련 소스코드들 저장 | `binary_search_iter.py` 등                     |
| `feature/problem3` | 문제 3번 관련 소스코드들 저장 | `frequency_sort.py` 등                     |
| `feature/problem4` | 문제 4번 관련 소스코드들 저장 | `dfs_code` 등                     |
| `feature/problem5` | 문제 5번 관련 소스코드들 저장 | `difference_visualize.py` 등                    |
| `feature/final` |추가 문제 관련 소스코드들 저장 |                      |

---

## 🛠️ 사용 언어

- Python 3.x

---

## 📋 시험 전 역할 분담

| 역할               | 담당자       | 설명 |
|--------------------|--------------|------|
| 팀장 (PM)          | 유시현       | Slack 및 PR 관리, 시간 체크, 전략 조율, 전 문제 리뷰 |
| 문제 1·2·3 담당     | 김수빈, 양찬 | 정렬, 이진 탐색, Counter 사용 문제 |
| 문제 4·5 담당       | 유시현, 김찬우 | DFS 재귀 및 대용량 처리 문제 |
| 최종 검토           | 전원         | 전체 코드 정리, 성능 테스트 및 검수 |
| 검수자              | 전원         | 제출 전 코드 실행 및 주석 점검 |

---

## ✅ 풀이한 문제 목록

| 문제 번호 | 문제 작성자 |
|-----------|--------------|
| problem1  | 양찬         |
| problem2  | 양찬         |
| problem3  | 김수빈       |
| problem4  | 유시현       |
| problem5  | 김찬우       |
| problem6  | 유시현       |

---

## 📌 파일 상세 설명 
### 1. 브런치 : main 
   
| 파일명 | 파일 설명|
|-----------|--------------|
| .gitignore |         |
| README.md | readme   |
| README.md |         |
| problem1.ipyb|1번 문제 최종 답안|
| problem2.ipyb|2번 문제 최종 답안|
| problem3.py|3번 문제 최종 답안|
| problem4.py|4번 문제 최종 답안|
| problem5.py|5번 문제 최종 답안|
| problem6.py|최종 문제 최종 답안|

Bubble_sort.py
Insertion sort.py
Merge sort.py
Quick sort.py
Selection Sort.py

### 2. 브런치 : feature/problem1
| 파일명 | 파일 설명|
|-----------|--------------|
| .gitignore |         |
| 1.ipynb | 정렬 알고리즘 종합 소스 코드 |
| Bubble_Sort.py | 버블 정렬 소스 코드 |
| Insertion Sort.py | 삽입 정렬 소스 코드 |
| Merge Sort.py | 병합 정렬 소스 코드 |
| Quick Sort.py | 퀵 정렬 소스 코드 |
| Selection Sort.py | 선택 정렬 소스 코드 |
| problem1.py | 문제 1번 풀이 과정 파일 |
| README.md |  readme |
| test.py | 깃허브 연동 테스트 파일  |

### 3. 브런치 : feature/problem2
| 파일명 | 파일 설명|
|-----------|--------------|
| .gitignore |         |
| README.md | readme   |
| binary_search_iter.py | 이진 탐색 알고리즘 소스코드(반복문버젼) |
| binary_search_recur.py | 이진 탐색 알고리즘 소스코드(재귀귀버젼) |
| 2.ipynb | 이진 탐색 알고리즘 종합 소스 코드 |
| problem2.py | 문제 2번 풀이 과정 파일  |
| test.py | 깃허브 연동 테스트 파일  |

### 4. 브런치 : feature/problem3
| 파일명 | 파일 설명|
|-----------|--------------|
| .gitignore |         |
| README.md | readme   |
| p3_source.py |  문제 3번 관련 소스 코드  |
| frequency_sort.py |         |
| frequency_sort2.py |         |
| problem3.py | 문제 3번 풀이 과정 파일  |

### 5. 브런치 : feature/problem4
| 파일명 | 파일 설명|
|-----------|--------------|
| .gitignore |         |
| README.md | readme   |
| dfs_chanwoo.py |  dfs 알고리즘 문제 탈출 소스 코드 |
| dfs_code.py |  dfs 알고리즘 관련 소스 코드 |
| obstacle_case.py |  문제 4번 장애물 추가 버전      |
| p4_sihyeon.py | 유시현 문제 4번 해결 (예제)  |
| problem4.py| 문제 4번 풀이 과정 파일 |
| rectangle_case.py |  grid가 직사각형일 경우 버전     |
| test.py | 깃허브 연동 테스트 파일  |

### 6. 브런치 : feature/problem5
| 파일명 | 파일 설명|
|-----------|--------------|
| .gitignore |         |
| README.md | readme   |
| difference_visualize.py| 병합,퀵,기수 정렬의 성능 비교 시각화 코드 파일   |
| problem5.py| 문제 5번 답안 작성용 샘플 코드 파일   |
| sort_func.py| 병합,퀵,기수 정렬 구현 소스 코드 파일   |
| sort_code.py| 정렬과 관련한 알고리즘 소스 코드 파일   |
| time_comparison.py |   정렬 시간 비교 관련 소스 코드 파일    |
| time_estimation.py |   각 정렬의 소요 시간 비교 히스토그램 소스 코드 파일    |
| test.py | 깃허브 커밋 관련 테스트 파일  |

### 7. 브런치 : feature/final
| 파일명 | 파일 설명|
|-----------|--------------|
| .gitignore |         |
| README.md | readme   |
| README.md |         |
| README.md |         |
| README.md |         |

### 8. 브런치 : dev
| 파일명 | 파일 설명|
|-----------|--------------|
| .gitignore | gitignore        |
| README.md |  readme      |
| test.py |   github 연결 확인용     |

## 문제 해결 과정 설명
##  1번 문제 (작성자 : 양찬)
문제 1에서는 문자열, 정수, 특수문자가 혼합된 리스트에서 정수로 변환 가능한 항목만 추출하고,
오름차순 정렬하여 총합을 구하는 작업이 요구되었다.

먼저 문자열 리스트 내에서 int()로 변환 가능한 값만 선별하기 위해 예외 처리를 활용한 is_integer_string() 함수를 정의했다.
이 과정을 통해 "3a", "NaN"과 같이 변환 불가능한 항목은 제거하고, "42", "-100"과 같은 숫자 형태 문자열은 정수로 변환할 수 있었다.

그 후, 정수 리스트에서 중복 제거를 위해 set() 자료구조를 활용하였고,
정렬은 내장 함수 없이 직접 구현하라는 조건에 따라 선택 정렬(Selection Sort) 알고리즘을 사용하였다.
선택 정렬은 구현이 직관적이며 데이터 수(200개)가 많지 않아 본 문제에서 적절하다고 판단하였다.

최종적으로 정렬된 숫자 리스트와 총합(PASSCORD1)을 출력하는 것으로 문제를 해결했다.
시간 복잡도는 O(n²)이지만 본 문제 크기에서는 무리가 없었다.
정렬 알고리즘 구현 및 숫자 필터링 조건을 명확하게 정의하는 것이 핵심이었다.
##  2번 문제 (작성자 : 양찬)
문제 2에서는 오름차순 정렬된 리스트 내에서 target 값의 첫 번째 등장 위치(start index)와
마지막 등장 위치(end index)를 중복을 고려하여 정확히 찾는 이진 탐색 알고리즘을 구현해야 했다.

먼저 입력된 리스트를 정렬한 후, find_start_index()와 find_end_index() 함수를 각각 정의하여
이진 탐색 기반으로 좌우 경계를 좁혀가는 방식으로 구현하였다.
start index는 target 이상이 가장 처음 등장하는 위치, end index는 target 이하가 가장 마지막 등장하는 위치를 의미했다.

문제의 핵심은 단순히 target이 존재하는지만 확인하는 것이 아니라,
동일한 값이 여러 개 존재할 경우에도 정확한 인덱스 범위를 계산해야 한다는 점이었다.
존재하지 않을 경우 "notfound"를 출력하게 하고, 존재한다면 start + end 값을 PASSCORD로 계산하여 출력하였다.

테스트 케이스를 직접 입력하여 결과를 검증했으며, target이 없을 때 예외 처리도 올바르게 작동함을 확인했다.
본 문제는 정렬, 이진 탐색의 정확한 경계 설정에 대한 이해가 중요했고,
조건문 흐름과 경계 조정이 익숙하지 않다면 헷갈릴 수 있는 문제였다.

##  3번 문제 (작성자 : )
---
##  4번 문제 (작성자 : 유시현 )
dfs 알고리즘을 사용하여 0에 도달하면 루프가 멈추게 되고, 찾지 못하면 false를 반환하며 찾지 못하였다는 신호와 멈추게 된다. 
방문 리스트를 만들어 각 좌표에 방문했는지 안했는지를 체크하고, 방문 한 경우 path 기록을 path 리스트에 저장한다.
모든 방문이 끝나고 0을 찾으면 True를 반환하며 재귀 루프를 탈출하게 되고, 방문한 기록들을 출력하여 어떤 과정을 거쳐 0에 도달하였는지 찾아내었다.
또한 step 은 각 좌표의 숫자를 의미하고, 그 숫자만큼 방향으로 나아가도록 설정하였다.

하지만, 문제에서 요구한 0을 찾는 모든 경우의수를 고려한 후 가장 최적의 답을 찾는 것은 해결하지 못하였다.
위치를 옮길 떄마다 모든 방향을 고려해야하는데, 현재 코드에서는 한 방향으로만 찾고 끝내어 해당 문제를 해결하지 못한다.
for 루프를 사용하여 모든 방향을 고려하도록 코드를 구성해보려고하였지만 성공하지 못하였다. 
현재 출력되는 경로의 숫자 합은 119라서 답안 제출을 119로 적어서 제출하였다.

---
##  5번 문제 (작성자 : 김찬우 )
arr은 1부터 1000000까지의 범위에 해당하는 양의 정수 1000000개를 모두 뽑아서 리스트로 만들었습니다. 
예제에서는 중복을 허용한 배열을 보여주셨는데 저는 정렬된 것을 더 쉽게 확인하고 싶어서 (1,2,3,4...으로 표시되도록) 이렇게 리스트를 만들었습니다.
sorted로 정렬된 리스트를 result 변수에 저장하여 결과를 보여줄 때 result를 출력하였고, 걸린 시간은 time.time()을 써서 시작과 종료 시간을 구한 후
종료 시간 - 시작 시간으로 계산하였습니다. 
조건을 만족하였을 때 PASS를 출력하라고 하셨는데 리스트가 잘 정렬되는지는 중간 중간 결과를 print 해보며 확인하여 걸린 시간이 3초 보다 더 걸렸는지, 
3초 이내였는지만 조건으로 하여 if else문을 작성하였습니다. (if spand_time>=3 or resut!=sorted(arr): print('FALSE')로 코드를 짤까 하다가 이미 정렬을 sorted() 함수로 했는데, 이에 대해서 또 sorted() 함수로 확인하는 것은 의미 없는 작업이다 라고 느껴져서 생략하였습니다.)

---
##  추가 문제 (작성자 :유시현)
문제 4번 코드를 바탕으로, 장애물이 있는 경우를 해결해보려고 노력하였다.
방문한 그리드가 '#'이라면 피하도록 설정을 추가하였다.

하지만, 문제 4번에서 주어진 그리드와는 달리 문자열의 리스트로 생성된 그리드라서 '#'을 인식하는데 문제가 생겼고,
시간이 부족하여 이후에 해결하지 못하였다. 

---
